# Принципи програмування у KPZlab1

## 1. **DRY** (Don't Repeat Yourself)

**Опис:** Код уникає дублювання, інкапсулюючи повторювану функціональність у багаторазові методи та класи.  

**Приклад:** Клас `Money` централізує логіку представлення та відображення грошових значень.  

**Відповідний код:** [Money.cs](KPZlab1/KPZlab1/Money.cs#L7-L17)

---

## 2. **KISS** (Keep It Simple, Stupid)

**Опис:** Дизайн і реалізація прості та зрозумілі, без зайвої складності.  

**Приклад:** Клас `Warehouse` використовує прості методи, такі як `AddProduct` та `ShowProducts`.  

**Відповідний код:** [Warehouse.cs](KPZlab1/KPZlab1/Warehouse.cs#L8-L24)

---

## 3. **SOLID Principles**

### **S - Single Responsibility Principle**  
**Опис:** Кожен клас має лише одну відповідальність.  
**Приклад:** Клас `Product` відповідає лише за представлення даних продукту.  
**Відповідний код:** [Product.cs](KPZlab1/KPZlab1/Product.cs#L7-L19)

### **O - Open/Closed Principle**  
**Опис:** Класи відкриті для розширення, але закриті для модифікації.  
**Приклад:** Нові методи для зміни ціни можуть бути додані до `Product` без змін існуючих методів.  
**Відповідний код:** [Product.cs](KPZlab1/KPZlab1/Product.cs#L15-L19)

### **L - Liskov Substitution Principle**  
**Опис:** Похідні класи повинні бути взаємозамінними з базовими класами.  
**Приклад:** Хоча успадкування не використовується, дизайн підтримує замінність через композицію.  
**Відповідний код:** [Warehouse.cs](KPZlab1/KPZlab1/Warehouse.cs#L8-L19)

### **I - Interface Segregation Principle**  
**Опис:** Інтерфейси повинні бути специфічними для клієнта, а не загальними.  
**Приклад:** Хоча інтерфейси прямо не використовуються, принцип простежується через чітко визначену відповідальність класів.

### **D - Dependency Inversion Principle**  
**Опис:** Високорівневі модулі не повинні залежати від низькорівневих.  
**Приклад:** Клас `Reporting` залежить від абстракції класу `Warehouse`, а не від конкретних структур даних.  
**Відповідний код:** [Reporting.cs](KPZlab1/KPZlab1/Reporting.cs#L7-L15)

---

## 4. **YAGNI** (You Aren't Gonna Need It)

**Опис:** Уникається реалізація функціоналу, поки в ньому немає потреби.  
**Приклад:** Реалізовано лише необхідні методи, такі як `ReducePrice` і `Display` (див. `Product.cs` і `Money.cs`).

---

## 5. **Composition Over Inheritance**

**Опис:** Код віддає перевагу композиції над успадкуванням для забезпечення гнучкості.  
**Приклад:** Клас `Product` використовує композицію, включаючи об'єкт `Money` для представлення ціни.  
**Відповідний код:** [Product.cs](KPZlab1/KPZlab1/Product.cs#L9-L12)

---

## 6. **Program to Interfaces, Not Implementations**

**Опис:** Хоча інтерфейси прямо не визначені, дизайн дозволяє легко інтегрувати їх у майбутньому.  
**Приклад:** Клас `Warehouse` можна легко розширити для реалізації інтерфейсу управління інвентарем.

---

## 7. **Fail Fast**

**Опис:** Код намагається виявити помилки якомога раніше.  
**Приклад:** Парсинг вводу та перетворення типів здійснюється просто, і помилки з'являються одразу при неправильних даних.  
**Відповідний код:** [Program.cs](KPZlab1/Kpzlab1.1/Program.cs#L12-L18)
